#, Field name, JSON field name, Field type, Length in bytes, Value
":math:`1`", ":ref:`Order <02_intermediate:Order>` binary format version number", "version", ":ref:`Byte <02_intermediate:Blockchain Data Types>`", ":math:`1`", "Must be :math:`3`."
":math:`2`", "Order sender public key", "senderPublicKey", "Array[:ref:`Byte <02_intermediate:Blockchain Data Types>`]", ":math:`32`"
":math:`3`", "Matcher public key", "matcherPublicKey", "Array[:ref:`Byte <02_intermediate:Blockchain Data Types>`]", ":math:`32`"
":math:`4.1`", "Asset B (amount asset) flag", " ", ":ref:`Byte <02_intermediate:Blockchain Data Types>`", ":math:`1`", "If token is DecentralCoins, then value is :math:`0`, else :math:`1`."
":math:`4.2`", "Asset B (amount Asset) ID", "amountAsset", "Array[:ref:`Byte <02_intermediate:Blockchain Data Types>`]", "S", "If token is not DecentralCoins, then :math:`S = 32`, else the field should be absent."
":math:`5.1`", "Asset A (price asset) flag", " ", ":ref:`Byte <02_intermediate:Blockchain Data Types>`", ":math:`1`", "If token is DecentralCoins, then value is :math:`0`, else :math:`1`."
":math:`5.2`", "Asset A (price asset) ID", "priceAsset", "Array[:ref:`Byte <02_intermediate:Blockchain Data Types>`]", "S", "If token is not DecentralCoins, then :math:`S = 32`, else the field should be absent."
":math:`6`", "Order type", "orderType", ":ref:`Byte <02_intermediate:Blockchain Data Types>`", ":math:`1`", "If order is for buying, then value is :math:`0`, if order is for selling, then value is  :math:`1`."
":math:`7`", "Amount of asset B (amount asset), which the order sender offers for one price asset(asset A)", "price", ":ref:`Long <02_intermediate:Blockchain Data Types>`", ":math:`8`", "Bytes in big-endian notation."
":math:`8``", "Amount of asset B (price asset), which the order sender wants to buy or send depending on order type", "amount", ":ref:`Long <02_intermediate:Blockchain Data Types>`", ":math:`8`", "Bytes in big-endian notation."
":math:`9`", "Amount of milliseconds from the beginning of Unix epoch till the moment of validation of order by matcher", "timestamp", ":ref:`Long <02_intermediate:Blockchain Data Types>`", ":math:`8`", "Bytes in big-endian notation."
":math:`10`", "Amount of milliseconds from the beginning of Unix epoch till the unfulfilled order cancellation", "expiration", ":ref:`Long <02_intermediate:Blockchain Data Types>`", ":math:`8`", "Bytes in big-endian notation."
":math:`11`", "Matcher fee", "matcherFee", ":ref:`Long <02_intermediate:Blockchain Data Types>`", ":math:`8`", "Bytes in big-endian notation."
":math:`12`", "Matcher fee token flag", " ", ":ref:`Byte <02_intermediate:Blockchain Data Types>`", ":math:`1`", "If token is DecentralCoins, then value is :math:`0`, else :math:`1`"
":math:`13`", "Matcher fee token", "matcherFeeAssetId", "Array[:ref:`Byte <02_intermediate:Blockchain Data Types>`]", "F", "If token is not DecentralCoins, then :math:`F = 32`, else the field should be absent."
":math:`14`", "Proofs", "proofs", "Array[Proof]", "S", "If the array is empty, then :math:`S = 3`. If the array is not empty, then :math:`S = 3 + 2 × N + (P_{1} + P_{2} + ... + P_{n})`, where :math:`N` is amount of proofs in the array, :math:`P_{n}` — size N-th proof in bytes. Maximum amount of proofs in the array is :math:`8`. Maximum length of each proof is :math:`64` bytes."